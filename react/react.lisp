(/debug "loading react.lisp!")

(defpackage :react
  (:use :common-lisp :jscl)
  (:export :dom-render :create-element :define-react-component :alist-from-plist)
  ;;
  ;; The following export line is generated by the following
  ;;   one-liner;
  ;;
  ;;  { sed -n -e '/^[(]%event-make-/{s/.* //;s/[)]//;s/^/:event-/;p;}' | sort -u } < react.lisp
  ;;
  ;; TODO: Arrange for macros to take care of the export.

  (:export
:event-alt-key
:event-animation-name
:event-bubbles
:event-button
:event-buttons
:event-cancelable
:event-changed-touches
:event-char-code
:event-client-x
:event-client-y
:event-clipboard-data
:event-ctrl-key
:event-current-target
:event-data
:event-default-prevented
:event-delta-mode
:event-delta-x
:event-delta-y
:event-delta-z
:event-detail
:event-elapsed-time
:event-event-phase
:event-get-modifier-state
:event-is-default-prevented
:event-is-propagation-stopped
:event-is-trusted
:event-key
:event-key-code
:event-locale
:event-location
:event-meta-key
:event-native-event
:event-page-x
:event-page-y
:event-prevent-default
:event-property-name
:event-pseudo-element
:event-related-target
:event-repeat
:event-screen-x
:event-screen-y
:event-shift-key
:event-stop-proagation
:event-target
:event-target-touches
:event-time-stamp
:event-touches
:event-type
:event-view
:event-which
)

  (:export :dom-element-value))

(in-package :react)

;;; Extender

(eval-when (:compile-toplevel :load-toplevel)
  (defun js-identifier-from-lisp-identifier (name)
    "Convert a Lisp identifier to a JavaScript camelCase identifier."
    (let ((words
            (loop for i = 0 then (+ 1 j)
                  as j = (position #\- name :start i)
                  collect (subseq name i j)
                  while j)))
      (apply #'jscl::concat (string-downcase (car words))
             (mapcar #'string-capitalize (cdr words))))))

(defun make-jsobj-keyname (key)
  "Make a keyname string from KEY."
  (cond
    ((stringp key) key)
    ((symbolp key) (js-identifier-from-lisp-identifier (symbol-name key)))
    (t (error "Cannot convert KEY `~S' to string." key))))

(defun make-jsobj (&rest init-plist)
  "Make a JavaScript object initialised with the given INIT-PLIST."
  (let ((object (jscl::make-new #j:Object)))
    (do ((tail init-plist (cddr tail)))
        ((null tail) object)
      (setf (jscl::oget object (make-jsobj-keyname (first tail)))
            (second tail)))
    object))

(eval-when (:compile-toplevel)
  (defun alist-from-plist (&rest plist)
    "Transform a PLIST to an alist."
    (let ((alist nil))
      (do ((tail plist (cddr tail)))
          ((null tail) alist)
        (push (list (first tail) (second tail)) alist)))))


;;; DOM, Elements and Components

(defun dom-render (element location)
  "Render ELEMENT at DOM LOCATION.

If LOCATION is a string, this is interpreted as a DOM-element ID and
the matching element is used as a rendering location."
  (cond
    ((stringp location)
     (funcall #j:ReactDOM:render element (#j:document:getElementById location)))
    (t
     (funcall #j:ReactDOM:render element location))))

(defun create-element (element &rest props-and-children)
  "Create a React ELEMENT with the given PROPS and CHILDREN.

The PROPS-AND-CHILDREN argument is polymorphic."
  (let (props children)
    (do ((tail props-and-children (cddr tail)))
        ((or (null tail) (not (symbolp (first tail))))
         (setf children tail))
      (case (first tail)
        ((:get-initial-state "getInitialState")
         (push (funcall (second tail)) props)
         (push "state" props))
        ((:style "style")
         (push (apply #'make-jsobj (second tail)) props)
         (push "style" props))
        (otherwise
         (push (second tail) props)
         (push (first tail) props))))
    (cond
      ((null children)
       (apply #j:_jsclReact_createElement
              (list element (apply #'make-jsobj props))))
      ((and (eql (length children) 1)(stringp (first children)))
       (apply #j:_jsclReact_createElement
              (list element (apply #'make-jsobj props) (first children))))
      ((and (consp children)(consp (car children)))
       (apply #j:_jsclReact_createElement
              (list element (apply #'make-jsobj props) (apply #'vector (car children)))))
      ((consp children)
       (apply #j:_jsclReact_createElement
              (list element (apply #'make-jsobj props) (apply #'vector children))))
      (t (progn
           (/debug "Error: Unsupported polymorphic PROPS-AND-CHILDREN.")
           (/log props-and-children)
           (error "Unsuppored polymorphic PROPS-AND-CHILDREN."))))))

(defun ll-create-component (class-name super slots)
  "Low-level function to create a react class with the given slots."
  (flet ((make-prop (key value)
           (cond
             ((stringp key)
              (make-jsobj :key (js-identifier-from-lisp-identifier key)
                          :value value))
             ((symbolp key)
              (make-jsobj :key (js-identifier-from-lisp-identifier (symbol-name key))
                          :value value))
             (t (progn
                  (/debug "Error: Unsupported polymorphic KEY.")
                  (/log key)
                  (error "Unsupported polymorphic KEY."))))))
    (let ((actual-super (if (null super) #j:React:Component super))
          props)
      (do ((tail slots (cddr tail)))
          ((null tail) props)
        (case (first tail)
          ((:get-initial-state "getInitialState")
           (push (make-prop "state" (funcall (second tail))) props))
          ((:style "style")
           (push (make-prop "style" (apply #'make-jsobj (second tail))) props))
          (otherwise
           (push (make-prop (first tail) (second tail)) props))))
      (funcall #j:_jsclReact_createComponent class-name actual-super (apply #'vector props)))))


(defmacro define-react-component
    (name-and-options props-slots state-slots &body method-slots)

  (let* ((%props (gensym "PROPS"))
         (%this (gensym "THIS"))
         (%get-initial-state (gensym "GET-INITIAL-STATE"))
         (%react-internal (gensym "REACT-INTERNAL"))
         (name-and-options (jscl::ensure-list name-and-options))
         (name (first name-and-options))
         (name-string (symbol-name name))
         (options (alist-from-plist (rest name-and-options)))
         (docstring (if (assoc :documentation options)
                        (second (assoc :documentation options))
                        (format nil "I am too lazy to write a meaningful documentation for `~A'." name-string)))
         (super (if (assoc :super options)
                    (second (assoc :super options))
                    nil))
         props-bindings
         state-bindings
         component-slots
         set-initial-state-body)

    ;; Prepare property-slots bindings
    (dolist (slot props-slots)
      (let* ((prop-name (first slot))
             (prop-name-string (symbol-name prop-name))
             (prop-alist (apply #'alist-from-plist (rest slot)))
             (prop-jsname (js-identifier-from-lisp-identifier prop-name-string))
             (prop-initform (second (assoc :initform prop-alist))))
        (push
         `(,prop-name (or (jscl::oget ,%props ,prop-jsname)
                          ,prop-initform))
         props-bindings)))

    ;; Prepare state-slots bindings
    (dolist (slot state-slots)
      (let* ((state-name (first slot))
             (state-name-string (symbol-name state-name))
             (state-alist (apply #'alist-from-plist (rest slot)))
             (state-jsname (js-identifier-from-lisp-identifier state-name-string))
             (state-initform (second (assoc :initform state-alist)))
             (get-state (intern (jscl::concat "GET-" state-name-string)))
             (set-state (intern (jscl::concat "SET-" state-name-string))))
        (push
         `(,get-state ()
                      (if (jscl::js-null-p (jscl::oget ,%this "state"))
                          ,state-initform
                          (jscl::oget ,%this "state" ,state-jsname)))
         state-bindings)
        (push
         `(,set-state (value)
                      (#j:_jsclReact_setState ,%this (make-jsobj ,state-jsname value)))
         state-bindings)
        (push
         `(setf (jscl::oget initial-state ,state-jsname) ,state-initform)
         set-initial-state-body)))

    ;; Prepare method bodies
    (flet ((make-name (name &rest args-and-body)
             (js-identifier-from-lisp-identifier (symbol-name name)))

           (event-handler-p (name args &rest body)
             (and (eql (length args) 1)
                  (eql (symbol-name (first args) "event"))))

           (make-method (name args &rest body)
             `(lambda ,args
                (let ((,%this jscl::this)
                      (,%props (jscl::oget jscl::this "props")))
                  (let ,props-bindings
                    (flet ,state-bindings ,@body)))))

           (make-event-handler (name args &rest body)
             `(lambda (event)
                (let ((*current-react-*event* event)
                      (,%this jscl::this)
                      (,%props (jscl::oget this "props")))
                  (let ,props-bindings
                    (flet ,state-bindings ,@body))))))

      (dolist (slot method-slots)
        (if (apply #'event-handler-p slot)
            (push (apply #'make-event-handler slot) component-slots)
            (push (apply #'make-method slot) component-slots))
        (push (apply #'make-name slot) component-slots)))

    (when docstring
      (push docstring component-slots)
      (push :documentation component-slots))

    (unless (null state-slots)
      (push `(lambda (&rest ,%react-internal)
               (let ((initial-state (jscl::make-new #j:Object)))
                 ,@set-initial-state-body
                 initial-state))
            component-slots)
      (push :get-initial-state component-slots))
    `(jscl::fset ',name (ll-create-component ,name-string ,super (list ,@component-slots)))))

;;; React Events

(defparameter *current-react-event* nil
  "The react event being processed.")

(defmacro %event-make-reader (name)
  (let* ((name-string (symbol-name name))
         (reader (intern (jscl::concat "EVENT-" name-string)))
         (js-property (js-identifier-from-lisp-identifier name-string)))
    `(defun ,reader (&optional (event *current-react-event*))
       (jscl::oget event ,js-property))))

(defmacro %event-make-unary-method (name)
  (let* ((name-string (symbol-name name))
         (method (intern (jscl::concat "EVENT-" name-string)))
         (js-property (js-identifier-from-lisp-identifier name-string)))
    `(defun ,method (&optional (event *current-react-event*))
       (funcall ((jscl::oget event ,js-property "bind") event)))))

(defmacro %event-make-binary-method (name)
  (let* ((name-string (symbol-name name))
         (method (intern (jscl::concat "EVENT-" name-string)))
         (js-property (js-identifier-from-lisp-identifier name-string)))
    `(defun ,method (arg1 &optional (event *current-react-event*))
       (funcall ((jscl::oget event ,js-property "bind") event arg1)))))

;; Every synthetic event has the following attributes:

(%event-make-reader bubbles)
(%event-make-reader cancelable)
(%event-make-reader current-target)
(%event-make-reader default-prevented)
(%event-make-reader event-phase)
(%event-make-reader is-trusted)
(%event-make-reader native-event)
(%event-make-reader target)
(%event-make-reader time-stamp)
(%event-make-reader type)

(%event-make-unary-method prevent-default)
(%event-make-unary-method stop-proagation)
(%event-make-unary-method is-default-prevented)
(%event-make-unary-method is-propagation-stopped)

;; Clipboard Events
;;  :on-copy, :on-cut, :on-paste

(%event-make-reader clipboard-data)

;; Composition Events
;;  :on-composition-end, :on-composition-start, :on-composition-update

(%event-make-reader data)

;; Keyboard Events
;;  :on-key-down, :on-key-press, :on-key-up

(%event-make-reader alt-key)
(%event-make-reader char-code)
(%event-make-reader ctrl-key)
(%event-make-reader key)
(%event-make-reader key-code)
(%event-make-reader locale)
(%event-make-reader location)
(%event-make-reader meta-key)
(%event-make-reader repeat)
(%event-make-reader shift-key)
(%event-make-reader which)

(%event-make-binary-method get-modifier-state)

;; Focus Events
;;  :on-focus :on-blur

(%event-make-reader related-target)

;; Form Events
;;  :on-change :on-input :on-invalid :on-submit

;; Mouse events
;;  :on-click :on-context-menu :on-double-click :on-drag :on-drag-end
;;  :on-drag-enter :on-drag-exit :on-drag-leave :on-drag-over
;;  :on-drag-start :on-drop :on-mouse-down :on-mouse-enter
;;  :on-mouse-leave :on-mouse-move :on-mouse-out :on-mouse-over
;;  :on-mouse-up

;(%event-make-reader alt-key)
(%event-make-reader button)
(%event-make-reader buttons)
(%event-make-reader client-x)
(%event-make-reader client-y)
;(%event-make-reader ctrl-key)
;(%event-make-reader meta-key)
(%event-make-reader page-x)
(%event-make-reader page-y)
;(%event-make-reader related-target)
(%event-make-reader screen-x)
(%event-make-reader screen-y)
;(%event-make-reader shift-key)

;(%event-make-binary-method get-modifier-state)

;; Selection Events
;;  :on-select

;; Touch Events
;;  :on-touch-cancel :on-touch-end :on-touch-move :on-touch-start

;(%event-make-reader alt-key)
(%event-make-reader changed-touches)
;(%event-make-reader ctrl-key)
;(%event-make-reader meta-key)
;(%event-make-reader related-target)
(%event-make-reader target-touches)
(%event-make-reader touches)
;(%event-make-reader shift-key)

;(%event-make-binary-method get-modifier-state)

;; UI Events
;;  :on-scroll

(%event-make-reader detail)
(%event-make-reader view)

;; Wheel Events
;;  :on-wheel

(%event-make-reader delta-mode)
(%event-make-reader delta-x)
(%event-make-reader delta-y)
(%event-make-reader delta-z)

;; Media Events
;;  :on-abort :on-can-play :on-can-play-through :on-duration-change
;;  :on-emptied :on-encrypted :on-ended :on-error :on-loaded-data
;;  :on-loaded-metadata :on-load-start :on-pause :on-play :on-playing
;;  :on-progress :on-rate-change :on-seeked :on-seeking :on-stalled
;;  :on-suspend :on-time-update :on-volume-change :on-waiting

;; Image Events
;;  :on-load :on-error

;; Animation Events
;;  :on-animation-end :on-animation-iteration :on-animation-end

(%event-make-reader animation-name)
(%event-make-reader pseudo-element)
(%event-make-reader elapsed-time)

;; Transition Events
;;  :on-transition-end

(%event-make-reader property-name)
;(%event-make-reader pseudo-element)
;(%event-make-reader elapsed-time)

;; Other Events
;;  :on-toggle


;;; DOM Elements

(defparameter *current-dom-element* nil
  "The DOM element being processed.")

(defmacro %dom-element-make-reader (name)
  (let* ((name-string (symbol-name name))
         (reader (intern (jscl::concat "DOM-ELEMENT-" name-string)))
         (js-property (js-identifier-from-lisp-identifier name-string)))
    `(defun ,reader (&optional (event *current-dom-element*))
       (jscl::oget event ,js-property))))

(%dom-element-make-reader value)
